From 28f77fb5daca4c295815b2cab2c4b6d62f01b227 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 13 Mar 2024 10:03:24 +0100
Subject: [PATCH 38/39] mf/session: Keep previously allocated sample with the
 transform streams.

---
 dlls/mf/session.c | 30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/dlls/mf/session.c b/dlls/mf/session.c
index 94e0aece2a4..5f385a518ba 100644
--- a/dlls/mf/session.c
+++ b/dlls/mf/session.c
@@ -155,6 +155,7 @@ struct transform_stream
     struct list samples;
     unsigned int requests;
     unsigned int min_buffer_size;
+    IMFSample *allocated_sample;
     BOOL draining;
 };
 
@@ -722,6 +723,12 @@ static void transform_stream_drop_samples(struct transform_stream *stream)
 {
     IMFSample *sample;
 
+    if (stream->allocated_sample)
+    {
+        IMFSample_Release(stream->allocated_sample);
+        stream->allocated_sample = NULL;
+    }
+
     while (SUCCEEDED(transform_stream_pop_sample(stream, &sample)))
         IMFSample_Release(sample);
 }
@@ -3198,14 +3205,26 @@ static void session_set_sink_stream_state(struct media_session *session, IMFStre
 static HRESULT transform_get_external_output_sample(const struct media_session *session, struct topo_node *transform,
         unsigned int output_index, const MFT_OUTPUT_STREAM_INFO *stream_info, IMFSample **sample)
 {
+    struct transform_stream *stream = &transform->u.transform.outputs[output_index];
     IMFTopologyNode *downstream_node;
     IMFMediaBuffer *buffer = NULL;
     struct topo_node *topo_node;
     unsigned int buffer_size;
-    DWORD downstream_input;
+    DWORD downstream_input, sample_size;
     TOPOID node_id;
     HRESULT hr;
 
+    buffer_size = max(stream_info->cbSize, stream->min_buffer_size);
+    if ((*sample = stream->allocated_sample))
+    {
+        stream->allocated_sample = NULL;
+        if (SUCCEEDED(IMFSample_GetTotalLength(*sample, &sample_size))
+                && sample_size >= buffer_size)
+            return S_OK;
+        IMFSample_Release(*sample);
+        *sample = NULL;
+    }
+
     if (FAILED(IMFTopologyNode_GetOutput(transform->node, output_index, &downstream_node, &downstream_input)))
     {
         WARN("Failed to get connected node for output %u.\n", output_index);
@@ -3223,8 +3242,6 @@ static HRESULT transform_get_external_output_sample(const struct media_session *
     }
     else
     {
-        buffer_size = max(stream_info->cbSize, transform->u.transform.outputs[output_index].min_buffer_size);
-
         hr = MFCreateAlignedMemoryBuffer(buffer_size, stream_info->cbAlignment, &buffer);
         if (SUCCEEDED(hr))
             hr = MFCreateSample(sample);
@@ -3288,7 +3305,12 @@ static HRESULT transform_node_pull_samples(const struct media_session *session,
         }
 
         if (buffers[i].pSample)
-            IMFSample_Release(buffers[i].pSample);
+        {
+            if (hr == MF_E_TRANSFORM_NEED_MORE_INPUT && !stream->allocated_sample)
+                stream->allocated_sample = buffers[i].pSample;
+            else
+                IMFSample_Release(buffers[i].pSample);
+        }
     }
 
     free(buffers);
-- 
2.44.0

