From 65e5c3fe28ce3678489389aaae1ea6e0c36c89e1 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Fri, 14 Jun 2024 03:20:32 +0200
Subject: [PATCH 40/45] Revert "winegstreamer: Add a queue of buffers to
 wg_parser to prevent locking up pipeline."

This reverts commit 46e5667cd8f5fafe0d4bdffdbf980200e5f841dd.
---
 dlls/winegstreamer/wg_parser.c | 104 +++------------------------------
 1 file changed, 9 insertions(+), 95 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index f72a6adb5f9..0d42e61cefb 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -137,10 +137,6 @@ struct wg_parser_stream
     GstBuffer *buffer;
     GstMapInfo map_info;
 
-    GstBuffer **queued_buffers;
-    size_t num_queued;
-    size_t queue_capacity;
-
     bool flushing, eos, enabled, has_caps, has_tags, has_buffer, no_more_pads;
 
     uint64_t duration;
@@ -149,8 +145,6 @@ struct wg_parser_stream
     int seq_id;
 
     guint64 seek_pos;
-
-    bool waiting;
 };
 
 static struct wg_parser *get_parser(wg_parser_t parser)
@@ -384,14 +378,8 @@ static GstBuffer *wait_parser_stream_buffer(struct wg_parser *parser, struct wg_
     /* Note that we can both have a buffer and stream->eos, in which case we
      * must return the buffer. */
 
-    if (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
-    {
-        stream->waiting = true;
-        pthread_cond_broadcast(&parser->stream_event_cond);
-        while (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
-            pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
-    }
-    stream->waiting = false;
+    while (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     return buffer;
 }
@@ -405,22 +393,6 @@ static void release_buffer(struct wg_parser *parser, struct wg_parser_stream *st
         stream->buffer = NULL;
     }
 
-    while (!stream->buffer && stream->num_queued)
-    {
-        GstBuffer *buffer = stream->queued_buffers[0];
-
-        memmove(stream->queued_buffers, stream->queued_buffers + 1, (stream->num_queued - 1) * sizeof(buffer));
-        stream->num_queued -= 1;
-
-        if (!gst_buffer_map(buffer, &stream->map_info, GST_MAP_READ))
-        {
-            GST_ERROR("Failed to map buffer.");
-            gst_buffer_unref(buffer);
-        }
-        else
-            stream->buffer = buffer;
-    }
-
     pthread_cond_broadcast(&parser->stream_event_cond);
 }
 
@@ -844,8 +816,6 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
 
             if (stream->enabled)
             {
-                size_t i;
-
                 stream->flushing = true;
                 pthread_cond_broadcast(&parser->stream_event_cond);
 
@@ -855,10 +825,6 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
                     gst_buffer_unref(stream->buffer);
                     stream->buffer = NULL;
                 }
-
-                for (i = 0; i < stream->num_queued; i++)
-                    gst_buffer_unref(stream->queued_buffers[i]);
-                stream->num_queued = 0;
             }
 
             pthread_mutex_unlock(&parser->mutex);
@@ -920,30 +886,10 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
     return TRUE;
 }
 
-static inline bool has_queue_space(struct wg_parser_stream *stream, GstBuffer *buffer)
-{
-    struct wg_parser *parser = stream->parser;
-    size_t i;
-
-    if (stream->current_format.major_type >= WG_MAJOR_TYPE_VIDEO && stream->num_queued > 256)
-        return false;
-
-    for (i = 0; i < parser->stream_count; i++)
-    {
-        struct wg_parser_stream *other_stream = parser->streams[i];
-        if (other_stream == stream)
-            continue;
-        if (!other_stream->buffer && other_stream->waiting)
-            return true;
-    }
-    return false;
-}
-
 static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *buffer)
 {
     struct wg_parser_stream *stream = gst_pad_get_element_private(pad);
     struct wg_parser *parser = stream->parser;
-    GstClockTime end_pts;
 
     GST_LOG("stream %p, buffer %p.", stream, buffer);
 
@@ -966,7 +912,7 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
     /* Allow this buffer to be flushed by GStreamer. We are effectively
      * implementing a queue object here. */
 
-    while (stream->enabled && !stream->flushing && stream->buffer && !has_queue_space(stream, buffer))
+    while (stream->enabled && !stream->flushing && stream->buffer)
         pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     if (!stream->enabled)
@@ -985,43 +931,15 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
         return GST_FLOW_FLUSHING;
     }
 
-    if (!stream->buffer)
+    if (!gst_buffer_map(buffer, &stream->map_info, GST_MAP_READ))
     {
-        if (!gst_buffer_map(buffer, &stream->map_info, GST_MAP_READ))
-        {
-            pthread_mutex_unlock(&parser->mutex);
-            GST_ERROR("Failed to map buffer.");
-            gst_buffer_unref(buffer);
-            return GST_FLOW_ERROR;
-        }
-
-        stream->buffer = buffer;
-    }
-    else
-    {
-        if (stream->queue_capacity < stream->num_queued + 1)
-        {
-            size_t capacity = stream->queue_capacity != 0 ? stream->queue_capacity * 2 : 32;
-            GstBuffer **queue = malloc(capacity * sizeof(*stream->queued_buffers));
-            if (!queue)
-            {
-                pthread_mutex_unlock(&parser->mutex);
-                GST_ERROR("Failed to allocate queue.");
-                gst_buffer_unref(buffer);
-                return GST_FLOW_ERROR;
-            }
-            memcpy(queue, stream->queued_buffers, stream->num_queued * sizeof(buffer));
-            free(stream->queued_buffers);
-            stream->queue_capacity = capacity;
-            stream->queued_buffers = queue;
-        }
-
-        stream->queued_buffers[stream->num_queued++] = buffer;
+        pthread_mutex_unlock(&parser->mutex);
+        GST_ERROR("Failed to map buffer.");
+        gst_buffer_unref(buffer);
+        return GST_FLOW_ERROR;
     }
 
-    end_pts = GST_BUFFER_PTS(buffer);
-    if (GST_BUFFER_DURATION_IS_VALID(buffer))
-        end_pts += GST_BUFFER_DURATION(buffer);
+    stream->buffer = buffer;
 
     pthread_mutex_unlock(&parser->mutex);
     pthread_cond_broadcast(&parser->stream_event_cond);
@@ -1211,10 +1129,6 @@ static void free_stream(struct wg_parser_stream *stream)
         stream->buffer = NULL;
     }
 
-    for (i = 0; i < stream->num_queued; i++)
-        gst_buffer_unref(stream->queued_buffers[i]);
-    free(stream->queued_buffers);
-
     for (i = 0; i < ARRAY_SIZE(stream->tags); ++i)
     {
         if (stream->tags[i])
-- 
2.45.2

