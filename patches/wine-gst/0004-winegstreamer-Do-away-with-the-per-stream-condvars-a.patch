From e8d238603701ff9e85b1f112a4f605ce721edcde Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Wed, 31 Jan 2024 17:42:54 +0100
Subject: [PATCH 04/20] winegstreamer: Do away with the per-stream condvars and
 use one parser-wide condvar instead.

This is required because the next commit checks conditions on all streams.
---
 dlls/winegstreamer/wg_parser.c | 27 ++++++++++-----------------
 1 file changed, 10 insertions(+), 17 deletions(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index 2bc1acb22ce..823cdfd9f54 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -90,6 +90,7 @@ struct wg_parser
     bool err_on, warn_on;
 
     pthread_cond_t read_cond, read_done_cond;
+    pthread_cond_t stream_event_cond;
     struct
     {
         GstBuffer *buffer;
@@ -122,7 +123,6 @@ struct wg_parser_stream
     GstSegment segment;
     struct wg_format preferred_format, current_format, codec_format;
 
-    pthread_cond_t event_cond, event_empty_cond;
     GstBuffer *buffer;
     GstMapInfo map_info;
 
@@ -288,8 +288,7 @@ static NTSTATUS wg_parser_stream_disable(void *args)
     stream->enabled = false;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_cond);
-    pthread_cond_signal(&stream->event_empty_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
     return S_OK;
 }
 
@@ -301,7 +300,7 @@ static GstBuffer *wait_parser_stream_buffer(struct wg_parser *parser, struct wg_
      * must return the buffer. */
 
     while (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
-        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     return buffer;
 }
@@ -416,7 +415,7 @@ static NTSTATUS wg_parser_stream_release_buffer(void *args)
     stream->buffer = NULL;
 
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_empty_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
 
     return S_OK;
 }
@@ -703,7 +702,7 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             pthread_mutex_lock(&parser->mutex);
             stream->eos = true;
             if (stream->enabled)
-                pthread_cond_signal(&stream->event_cond);
+                pthread_cond_signal(&parser->stream_event_cond);
             else
                 pthread_cond_signal(&parser->init_cond);
             pthread_mutex_unlock(&parser->mutex);
@@ -715,7 +714,7 @@ static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
             if (stream->enabled)
             {
                 stream->flushing = true;
-                pthread_cond_signal(&stream->event_empty_cond);
+                pthread_cond_signal(&parser->stream_event_cond);
 
                 if (stream->buffer)
                 {
@@ -793,7 +792,7 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
      * implementing a queue object here. */
 
     while (stream->enabled && !stream->flushing && stream->buffer)
-        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
+        pthread_cond_wait(&parser->stream_event_cond, &parser->mutex);
 
     if (!stream->enabled)
     {
@@ -822,7 +821,7 @@ static GstFlowReturn sink_chain_cb(GstPad *pad, GstObject *parent, GstBuffer *bu
     stream->buffer = buffer;
 
     pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_cond);
+    pthread_cond_signal(&parser->stream_event_cond);
 
     /* The chain callback is given a reference to the buffer. Transfer that
      * reference to the stream object, which will release it in
@@ -926,8 +925,6 @@ static struct wg_parser_stream *create_stream(struct wg_parser *parser, char *id
     stream->number = parser->stream_count;
     stream->no_more_pads = true;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
-    pthread_cond_init(&stream->event_cond, NULL);
-    pthread_cond_init(&stream->event_empty_cond, NULL);
 
     sprintf(pad_name, "qz_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
@@ -959,9 +956,6 @@ static void free_stream(struct wg_parser_stream *stream)
         stream->buffer = NULL;
     }
 
-    pthread_cond_destroy(&stream->event_cond);
-    pthread_cond_destroy(&stream->event_empty_cond);
-
     for (i = 0; i < ARRAY_SIZE(stream->tags); ++i)
     {
         if (stream->tags[i])
@@ -2007,10 +2001,8 @@ static NTSTATUS wg_parser_disconnect(void *args)
     /* Unblock all of our streams. */
     pthread_mutex_lock(&parser->mutex);
     for (i = 0; i < parser->stream_count; ++i)
-    {
         parser->streams[i]->flushing = true;
-        pthread_cond_signal(&parser->streams[i]->event_empty_cond);
-    }
+    pthread_cond_signal(&parser->stream_event_cond);
     pthread_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
@@ -2184,6 +2176,7 @@ static NTSTATUS wg_parser_create(void *args)
     pthread_cond_init(&parser->init_cond, NULL);
     pthread_cond_init(&parser->read_cond, NULL);
     pthread_cond_init(&parser->read_done_cond, NULL);
+    pthread_cond_init(&parser->stream_event_cond, NULL);
     parser->init_gst = init_funcs[params->type];
     parser->output_compressed = params->output_compressed;
     parser->err_on = params->err_on;
-- 
2.44.0

