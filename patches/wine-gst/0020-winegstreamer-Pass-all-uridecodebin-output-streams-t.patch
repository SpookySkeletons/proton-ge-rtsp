From 2e0d73841f50c7ed014ab2693aa436717cd83fbd Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Wed, 31 Jan 2024 17:42:54 +0100
Subject: [PATCH 20/32] winegstreamer: Pass all uridecodebin output streams
 through a multiqueue.

---
 dlls/winegstreamer/wg_parser.c | 92 +++++++++++++++++++++++++++++++++-
 1 file changed, 91 insertions(+), 1 deletion(-)

diff --git a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
index fd8fdc74d6f..5a06f1871e4 100644
--- a/dlls/winegstreamer/wg_parser.c
+++ b/dlls/winegstreamer/wg_parser.c
@@ -71,7 +71,7 @@ struct wg_parser
     struct wg_parser_stream **streams;
     unsigned int stream_count;
 
-    GstElement *container, *decodebin;
+    GstElement *container, *decodebin, *multiqueue;
     GstBus *bus;
     GstTaskPool *task_pool;
     GstPad *my_src;
@@ -1179,6 +1179,76 @@ static void free_stream(struct wg_parser_stream *stream)
     free(stream);
 }
 
+static bool connect_to_multiqueue(struct wg_parser *parser, unsigned int id, GstElement **first, GstElement **last)
+{
+    GstPad *src_pad = NULL, *mq_sink_pad = NULL, *mq_src_pad = NULL, *i_sink_pad = NULL;
+    GstPadTemplate *template = NULL;
+    GstElement *identity = NULL;
+    char pad_name[16];
+    bool ret = false;
+
+    if (!parser->multiqueue)
+        return true;
+
+    if (!(src_pad = gst_element_get_static_pad(*last, "src")))
+    {
+        gchar *name = gst_element_get_name(*last);
+        GST_ERROR("Failed to find src pad on %s", name);
+        g_free(name);
+        goto error;
+    }
+
+    if (!(template = gst_element_class_get_pad_template(GST_ELEMENT_GET_CLASS(parser->multiqueue), "sink_%u")))
+        goto error;
+    sprintf(pad_name, "sink_%u", id);
+    if (!(mq_sink_pad = gst_element_request_pad(parser->multiqueue, template, pad_name, NULL)))
+        goto error;
+    sprintf(pad_name, "src_%u", id);
+    if (!(mq_src_pad = gst_element_get_static_pad(parser->multiqueue, pad_name)))
+        goto error;
+
+    if (gst_pad_link(src_pad, mq_sink_pad))
+    {
+        gchar *src_name = gst_pad_get_name(src_pad), *sink_name = gst_pad_get_name(mq_sink_pad);
+        GST_ERROR("Failed to link element pad %s with pad %s", src_name, sink_name);
+        g_free(sink_name);
+        g_free(src_name);
+        goto error;
+    }
+
+    if (!(identity = create_element("identity", "base")) ||
+            !gst_bin_add(GST_BIN(parser->container), identity) ||
+            !gst_element_sync_state_with_parent(identity))
+    {
+        gchar *name = gst_element_get_name(identity);
+        GST_ERROR("Failed to link %s element.", name);
+        g_free(name);
+        goto error;
+    }
+    if (!(i_sink_pad = gst_element_get_static_pad(identity, "sink")))
+        goto error;
+
+    if (gst_pad_link(mq_src_pad, i_sink_pad))
+    {
+        gchar *src_name = gst_pad_get_name(mq_src_pad), *sink_name = gst_pad_get_name(i_sink_pad);
+        GST_ERROR("Failed to link element pad %s with pad %s", src_name, sink_name);
+        g_free(sink_name);
+        g_free(src_name);
+        goto error;
+    }
+
+    gst_object_ref(identity);
+    *last = identity;
+    ret = true;
+
+error:
+    if (i_sink_pad) gst_object_unref(i_sink_pad);
+    if (mq_src_pad) gst_object_unref(mq_src_pad);
+    if (mq_sink_pad) gst_object_unref(mq_sink_pad);
+    if (src_pad) gst_object_unref(src_pad);
+    return ret;
+}
+
 static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser_stream *stream)
 {
     GstElement *element = NULL, *first = NULL, *last = NULL;
@@ -1215,6 +1285,9 @@ static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser
                 || !append_element(parser->container, element, &first, &last))
             return false;
 
+        if (!connect_to_multiqueue(parser, stream->number, &first, &last))
+            return false;
+
         if (!link_src_to_element(pad, first) || !link_element_to_sink(last, stream->my_sink))
             return false;
     }
@@ -1299,6 +1372,9 @@ static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser
                 || !append_element(parser->container, element, &first, &last))
             return false;
 
+        if (!connect_to_multiqueue(parser, stream->number, &first, &last))
+            return false;
+
         if (!link_src_to_element(pad, first) || !link_element_to_sink(last, stream->my_sink))
             return false;
     }
@@ -1316,6 +1392,9 @@ static bool stream_create_post_processing_elements(GstPad *pad, struct wg_parser
                 || !append_element(parser->container, element, &first, &last))
             return false;
 
+        if (!connect_to_multiqueue(parser, stream->number, &first, &last))
+            return false;
+
         if (!link_src_to_element(pad, first) || !link_element_to_sink(last, stream->my_sink))
             return false;
     }
@@ -2296,6 +2375,17 @@ static BOOL uridecodebin_parser_init_gst(struct wg_parser *parser)
 {
     GstElement *element;
 
+    if (!parser->multiqueue &&
+            (!(parser->multiqueue = create_element("multiqueue", "base")) ||
+             !gst_bin_add(GST_BIN(parser->container), parser->multiqueue) ||
+             !gst_element_sync_state_with_parent(parser->multiqueue)))
+        return FALSE;
+
+    g_object_set(parser->multiqueue, "max-size-buffers", (guint)-1, NULL);
+    g_object_set(parser->multiqueue, "max-size-bytes", (guint)-1, NULL);
+    g_object_set(parser->multiqueue, "max-size-time", 11 * GST_SECOND, NULL);
+    g_object_set(parser->multiqueue, "high-watermark", 0.5, NULL);
+
     if (!(element = create_element("uridecodebin", "base")))
         return FALSE;
 
-- 
2.44.0

